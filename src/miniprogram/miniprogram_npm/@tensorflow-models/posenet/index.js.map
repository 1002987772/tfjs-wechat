{"version":3,"sources":["index.js","checkpoint_loader.js","mobilenet.js","multiPose/decodeMultiplePoses.js","util.js","keypoints.js","multiPose/buildPartWithScoreQueue.js","multiPose/maxHeap.js","multiPose/decodePose.js","multiPose/util.js","posenet_model.js","checkpoints.js","singlePose/decodeSinglePose.js","singlePose/argmax2d.js","singlePose/util.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AKfA,AHSA,ACHA,ACHA;AHUA,ADGA,AKfA,AHSA,ACHA,ACHA;AHUA,ADGA,AKfA,AHSA,ACHA,ACHA;AHUA,ADGA,AKfA,AHSA,AIZA,AHSA,ACHA;AHUA,ADGA,AKfA,AHSA,AIZA,AHSA,ACHA;AHUA,ADGA,AKfA,AHSA,AIZA,AHSA,ACHA;AHUA,ADGA,AKfA,AHSA,AIZA,AHSA,AIZA,AHSA;AHUA,ADGA,AKfA,AHSA,AIZA,AHSA,AIZA,AHSA;AHUA,AIZA,AHSA,AIZA,AHSA,AIZA,AHSA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AHSA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AHSA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AHSA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ALeA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ALeA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ALeA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,ANkBA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,ANkBA;AHUA,AIZA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,ANkBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,ANkBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,ANkBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,ANkBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,ARwBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,ARwBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,ARwBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,ARwBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,ARwBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,ARwBA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,ANkBA,AHSA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,AT2BA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,AT2BA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,AT2BA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,AT2BA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,AT2BA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,AU9BA,AT2BA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AGTA,ADGA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,AIZA,AHSA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AENA,ACHA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,AENA,AV8BA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,ADGA,AGTA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AKfA,AENA,AENA,ARwBA;AHUA,ACHA,ACHA,AOrBA,AENA,ARwBA;AHUA,ACHA,ACHA,AOrBA,AENA,ARwBA;AHUA,ACHA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,AENA,ARwBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA,ANkBA;AFOA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar checkpoint_loader_1 = require(\"./checkpoint_loader\");\nexports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;\nvar mobilenet_1 = require(\"./mobilenet\");\nexports.MobileNet = mobilenet_1.MobileNet;\nexports.mobileNetArchitectures = mobilenet_1.mobileNetArchitectures;\nvar decodeMultiplePoses_1 = require(\"./multiPose/decodeMultiplePoses\");\nexports.decodeMultiplePoses = decodeMultiplePoses_1.decodeMultiplePoses;\nvar posenet_model_1 = require(\"./posenet_model\");\nexports.load = posenet_model_1.load;\nexports.PoseNet = posenet_model_1.PoseNet;\nvar decodeSinglePose_1 = require(\"./singlePose/decodeSinglePose\");\nexports.decodeSinglePose = decodeSinglePose_1.decodeSinglePose;\nvar keypoints_1 = require(\"./keypoints\");\nexports.partIds = keypoints_1.partIds;\nexports.partNames = keypoints_1.partNames;\nexports.poseChain = keypoints_1.poseChain;\nvar util_1 = require(\"./util\");\nexports.getAdjacentKeyPoints = util_1.getAdjacentKeyPoints;\nexports.getBoundingBox = util_1.getBoundingBox;\nexports.getBoundingBoxPoints = util_1.getBoundingBoxPoints;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar MANIFEST_FILE = 'manifest.json';\nvar CheckpointLoader = (function () {\n    function CheckpointLoader(urlPath) {\n        this.urlPath = urlPath;\n        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {\n            this.urlPath += '/';\n        }\n    }\n    CheckpointLoader.prototype.loadManifest = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', _this.urlPath + MANIFEST_FILE);\n            xhr.onload = function () {\n                _this.checkpointManifest = JSON.parse(xhr.responseText);\n                resolve();\n            };\n            xhr.onerror = function (error) {\n                throw new Error(MANIFEST_FILE + \" not found at \" + _this.urlPath + \". \" + error);\n            };\n            xhr.send();\n        });\n    };\n    CheckpointLoader.prototype.getCheckpointManifest = function () {\n        var _this = this;\n        if (this.checkpointManifest == null) {\n            return new Promise(function (resolve, reject) {\n                _this.loadManifest().then(function () {\n                    resolve(_this.checkpointManifest);\n                });\n            });\n        }\n        return new Promise(function (resolve, reject) {\n            resolve(_this.checkpointManifest);\n        });\n    };\n    CheckpointLoader.prototype.getAllVariables = function () {\n        var _this = this;\n        if (this.variables != null) {\n            return new Promise(function (resolve, reject) {\n                resolve(_this.variables);\n            });\n        }\n        return new Promise(function (resolve, reject) {\n            _this.getCheckpointManifest().then(function (checkpointDefinition) {\n                var variableNames = Object.keys(_this.checkpointManifest);\n                var variablePromises = [];\n                for (var i = 0; i < variableNames.length; i++) {\n                    variablePromises.push(_this.getVariable(variableNames[i]));\n                }\n                Promise.all(variablePromises).then(function (variables) {\n                    _this.variables = {};\n                    for (var i = 0; i < variables.length; i++) {\n                        _this.variables[variableNames[i]] = variables[i];\n                    }\n                    resolve(_this.variables);\n                });\n            });\n        });\n    };\n    CheckpointLoader.prototype.getVariable = function (varName) {\n        var _this = this;\n        if (!(varName in this.checkpointManifest)) {\n            throw new Error('Cannot load non-existant variable ' + varName);\n        }\n        var variableRequestPromiseMethod = function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            xhr.responseType = 'arraybuffer';\n            var fname = _this.checkpointManifest[varName].filename;\n            xhr.open('GET', _this.urlPath + fname);\n            xhr.onload = function () {\n                if (xhr.status === 404) {\n                    throw new Error(\"Not found variable \" + varName);\n                }\n                var values = new Float32Array(xhr.response);\n                var tensor = tfjs_core_1.Tensor.make(_this.checkpointManifest[varName].shape, { values: values });\n                resolve(tensor);\n            };\n            xhr.onerror = function (error) {\n                throw new Error(\"Could not fetch variable \" + varName + \": \" + error);\n            };\n            xhr.send();\n        };\n        if (this.checkpointManifest == null) {\n            return new Promise(function (resolve, reject) {\n                _this.loadManifest().then(function () {\n                    new Promise(variableRequestPromiseMethod).then(resolve);\n                });\n            });\n        }\n        return new Promise(variableRequestPromiseMethod);\n    };\n    return CheckpointLoader;\n}());\nexports.CheckpointLoader = CheckpointLoader;\n//# sourceMappingURL=checkpoint_loader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar mobileNet100Architecture = [\n    ['conv2d', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1]\n];\nvar mobileNet75Architecture = [\n    ['conv2d', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1]\n];\nvar mobileNet50Architecture = [\n    ['conv2d', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1]\n];\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\nfunction assertValidOutputStride(outputStride) {\n    tf.util.assert(typeof outputStride === 'number', 'outputStride is not a number');\n    tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(outputStride) >= 0, \"outputStride of \" + outputStride + \" is invalid. \" +\n        \"It must be either 8, 16, or 32\");\n}\nexports.assertValidOutputStride = assertValidOutputStride;\nfunction assertValidResolution(resolution, outputStride) {\n    tf.util.assert(typeof resolution === 'number', 'resolution is not a number');\n    tf.util.assert((resolution - 1) % outputStride === 0, \"resolution of \" + resolution + \" is invalid for output stride \" +\n        (outputStride + \".\"));\n}\nexports.assertValidResolution = assertValidResolution;\nfunction assertValidScaleFactor(imageScaleFactor) {\n    tf.util.assert(typeof imageScaleFactor === 'number', 'imageScaleFactor is not a number');\n    tf.util.assert(imageScaleFactor >= 0.2 && imageScaleFactor <= 1.0, 'imageScaleFactor must be between 0.2 and 1.0');\n}\nexports.assertValidScaleFactor = assertValidScaleFactor;\nexports.mobileNetArchitectures = {\n    100: mobileNet100Architecture,\n    75: mobileNet75Architecture,\n    50: mobileNet50Architecture\n};\nfunction toOutputStridedLayers(convolutionDefinition, outputStride) {\n    var currentStride = 1;\n    var rate = 1;\n    return convolutionDefinition.map(function (_a, blockId) {\n        var convType = _a[0], stride = _a[1];\n        var layerStride, layerRate;\n        if (currentStride === outputStride) {\n            layerStride = 1;\n            layerRate = rate;\n            rate *= stride;\n        }\n        else {\n            layerStride = stride;\n            layerRate = 1;\n            currentStride *= stride;\n        }\n        return {\n            blockId: blockId,\n            convType: convType,\n            stride: layerStride,\n            rate: layerRate,\n            outputStride: currentStride\n        };\n    });\n}\nvar MobileNet = (function () {\n    function MobileNet(variables, convolutionDefinitions) {\n        this.PREPROCESS_DIVISOR = tf.scalar(255.0 / 2);\n        this.ONE = tf.scalar(1);\n        this.variables = variables;\n        this.convolutionDefinitions = convolutionDefinitions;\n    }\n    MobileNet.prototype.predict = function (input, outputStride) {\n        var _this = this;\n        var preprocessedInput = tf.cast(input, 'float32').div(this.PREPROCESS_DIVISOR).sub(this.ONE);\n        var layers = toOutputStridedLayers(this.convolutionDefinitions, outputStride);\n        return layers.reduce(function (previousLayer, _a) {\n            var blockId = _a.blockId, stride = _a.stride, convType = _a.convType, rate = _a.rate;\n            if (convType === 'conv2d') {\n                return _this.conv(previousLayer, stride, blockId);\n            }\n            else if (convType === 'separableConv') {\n                return _this.separableConv(previousLayer, stride, blockId, rate);\n            }\n            else {\n                throw Error(\"Unknown conv type of \" + convType);\n            }\n        }, preprocessedInput);\n    };\n    MobileNet.prototype.convToOutput = function (mobileNetOutput, outputLayerName) {\n        return mobileNetOutput.conv2d(this.weights(outputLayerName), 1, 'same')\n            .add(this.biases(outputLayerName));\n    };\n    MobileNet.prototype.conv = function (inputs, stride, blockId) {\n        return inputs\n            .conv2d(this.weights(\"Conv2d_\" + String(blockId)), stride, 'same')\n            .add(this.biases(\"Conv2d_\" + String(blockId)))\n            .clipByValue(0, 6);\n    };\n    MobileNet.prototype.separableConv = function (inputs, stride, blockID, dilations) {\n        if (dilations === void 0) { dilations = 1; }\n        var dwLayer = \"Conv2d_\" + String(blockID) + \"_depthwise\";\n        var pwLayer = \"Conv2d_\" + String(blockID) + \"_pointwise\";\n        var x1 = inputs\n            .depthwiseConv2D(this.depthwiseWeights(dwLayer), stride, 'same', 'NHWC', dilations)\n            .add(this.biases(dwLayer))\n            .clipByValue(0, 6);\n        var x2 = x1.conv2d(this.weights(pwLayer), [1, 1], 'same')\n            .add(this.biases(pwLayer))\n            .clipByValue(0, 6);\n        return x2;\n    };\n    MobileNet.prototype.weights = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/weights\"];\n    };\n    MobileNet.prototype.biases = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/biases\"];\n    };\n    MobileNet.prototype.depthwiseWeights = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/depthwise_weights\"];\n    };\n    MobileNet.prototype.dispose = function () {\n        for (var varName in this.variables) {\n            this.variables[varName].dispose();\n        }\n    };\n    return MobileNet;\n}());\nexports.MobileNet = MobileNet;\n//# sourceMappingURL=mobilenet.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar buildPartWithScoreQueue_1 = require(\"./buildPartWithScoreQueue\");\nvar decodePose_1 = require(\"./decodePose\");\nvar util_2 = require(\"./util\");\nfunction withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, _a, keypointId) {\n    var x = _a.x, y = _a.y;\n    return poses.some(function (_a) {\n        var keypoints = _a.keypoints;\n        var correspondingKeypoint = keypoints[keypointId].position;\n        return util_2.squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\n            squaredNmsRadius;\n    });\n}\nfunction getInstanceScore(existingPoses, squaredNmsRadius, instanceKeypoints) {\n    var notOverlappedKeypointScores = instanceKeypoints.reduce(function (result, _a, keypointId) {\n        var position = _a.position, score = _a.score;\n        if (!withinNmsRadiusOfCorrespondingPoint(existingPoses, squaredNmsRadius, position, keypointId)) {\n            result += score;\n        }\n        return result;\n    }, 0.0);\n    return notOverlappedKeypointScores /= instanceKeypoints.length;\n}\nvar kLocalMaximumRadius = 1;\nfunction decodeMultiplePoses(heatmapScores, offsets, displacementsFwd, displacementsBwd, outputStride, maxPoseDetections, scoreThreshold, nmsRadius) {\n    if (scoreThreshold === void 0) { scoreThreshold = 0.5; }\n    if (nmsRadius === void 0) { nmsRadius = 20; }\n    return __awaiter(this, void 0, void 0, function () {\n        var poses, _a, scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, queue, squaredNmsRadius, root, rootImageCoords, keypoints, score;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    poses = [];\n                    return [4, util_1.toTensorBuffers3D([heatmapScores, offsets, displacementsFwd, displacementsBwd])];\n                case 1:\n                    _a = _b.sent(), scoresBuffer = _a[0], offsetsBuffer = _a[1], displacementsFwdBuffer = _a[2], displacementsBwdBuffer = _a[3];\n                    queue = buildPartWithScoreQueue_1.buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius, scoresBuffer);\n                    squaredNmsRadius = nmsRadius * nmsRadius;\n                    while (poses.length < maxPoseDetections && !queue.empty()) {\n                        root = queue.dequeue();\n                        rootImageCoords = util_2.getImageCoords(root.part, outputStride, offsetsBuffer);\n                        if (withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\n                            continue;\n                        }\n                        keypoints = decodePose_1.decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);\n                        score = getInstanceScore(poses, squaredNmsRadius, keypoints);\n                        poses.push({ keypoints: keypoints, score: score });\n                    }\n                    return [2, poses];\n            }\n        });\n    });\n}\nexports.decodeMultiplePoses = decodeMultiplePoses;\n//# sourceMappingURL=decodeMultiplePoses.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar keypoints_1 = require(\"./keypoints\");\nfunction eitherPointDoesntMeetConfidence(a, b, minConfidence) {\n    return (a < minConfidence || b < minConfidence);\n}\nfunction getAdjacentKeyPoints(keypoints, minConfidence) {\n    return keypoints_1.connectedPartIndices.reduce(function (result, _a) {\n        var leftJoint = _a[0], rightJoint = _a[1];\n        if (eitherPointDoesntMeetConfidence(keypoints[leftJoint].score, keypoints[rightJoint].score, minConfidence)) {\n            return result;\n        }\n        result.push([keypoints[leftJoint], keypoints[rightJoint]]);\n        return result;\n    }, []);\n}\nexports.getAdjacentKeyPoints = getAdjacentKeyPoints;\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\nfunction getBoundingBox(keypoints) {\n    return keypoints.reduce(function (_a, _b) {\n        var maxX = _a.maxX, maxY = _a.maxY, minX = _a.minX, minY = _a.minY;\n        var _c = _b.position, x = _c.x, y = _c.y;\n        return {\n            maxX: Math.max(maxX, x),\n            maxY: Math.max(maxY, y),\n            minX: Math.min(minX, x),\n            minY: Math.min(minY, y)\n        };\n    }, {\n        maxX: NEGATIVE_INFINITY,\n        maxY: NEGATIVE_INFINITY,\n        minX: POSITIVE_INFINITY,\n        minY: POSITIVE_INFINITY\n    });\n}\nexports.getBoundingBox = getBoundingBox;\nfunction getBoundingBoxPoints(keypoints) {\n    var _a = getBoundingBox(keypoints), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n    return [\n        { x: minX, y: minY }, { x: maxX, y: minY }, { x: maxX, y: maxY },\n        { x: minX, y: maxY }\n    ];\n}\nexports.getBoundingBoxPoints = getBoundingBoxPoints;\nfunction toTensorBuffer(tensor, type) {\n    if (type === void 0) { type = 'float32'; }\n    return __awaiter(this, void 0, void 0, function () {\n        var tensorData;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4, tensor.data()];\n                case 1:\n                    tensorData = _a.sent();\n                    return [2, new tf.TensorBuffer(tensor.shape, type, tensorData)];\n            }\n        });\n    });\n}\nexports.toTensorBuffer = toTensorBuffer;\nfunction toTensorBuffers3D(tensors) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2, Promise.all(tensors.map(function (tensor) { return toTensorBuffer(tensor, 'float32'); }))];\n        });\n    });\n}\nexports.toTensorBuffers3D = toTensorBuffers3D;\nfunction scalePose(pose, scaleX, scaleY) {\n    return {\n        score: pose.score,\n        keypoints: pose.keypoints.map(function (_a) {\n            var score = _a.score, part = _a.part, position = _a.position;\n            return ({\n                score: score,\n                part: part,\n                position: { x: position.x * scaleX, y: position.y * scaleY }\n            });\n        })\n    };\n}\nexports.scalePose = scalePose;\nfunction scalePoses(poses, scaleY, scaleX) {\n    if (scaleX === 1 && scaleY === 1) {\n        return poses;\n    }\n    return poses.map(function (pose) { return scalePose(pose, scaleX, scaleY); });\n}\nexports.scalePoses = scalePoses;\nfunction getValidResolution(imageScaleFactor, inputDimension, outputStride) {\n    var evenResolution = inputDimension * imageScaleFactor - 1;\n    return evenResolution - (evenResolution % outputStride) + 1;\n}\nexports.getValidResolution = getValidResolution;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.partNames = [\n    'nose', 'leftEye', 'rightEye', 'leftEar', 'rightEar', 'leftShoulder',\n    'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist',\n    'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'\n];\nexports.NUM_KEYPOINTS = exports.partNames.length;\nexports.partIds = exports.partNames.reduce(function (result, jointName, i) {\n    result[jointName] = i;\n    return result;\n}, {});\nvar connectedPartNames = [\n    ['leftHip', 'leftShoulder'], ['leftElbow', 'leftShoulder'],\n    ['leftElbow', 'leftWrist'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['rightHip', 'rightShoulder'],\n    ['rightElbow', 'rightShoulder'], ['rightElbow', 'rightWrist'],\n    ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'],\n    ['leftShoulder', 'rightShoulder'], ['leftHip', 'rightHip']\n];\nexports.poseChain = [\n    ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n    ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n    ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n    ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n    ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n    ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n    ['rightKnee', 'rightAnkle']\n];\nexports.connectedPartIndices = connectedPartNames.map(function (_a) {\n    var jointNameA = _a[0], jointNameB = _a[1];\n    return ([exports.partIds[jointNameA], exports.partIds[jointNameB]]);\n});\n//# sourceMappingURL=keypoints.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar maxHeap_1 = require(\"./maxHeap\");\nfunction scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores) {\n    var _a = scores.shape, height = _a[0], width = _a[1];\n    var localMaximum = true;\n    var yStart = Math.max(heatmapY - localMaximumRadius, 0);\n    var yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);\n    for (var yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {\n        var xStart = Math.max(heatmapX - localMaximumRadius, 0);\n        var xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);\n        for (var xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {\n            if (scores.get(yCurrent, xCurrent, keypointId) > score) {\n                localMaximum = false;\n                break;\n            }\n        }\n        if (!localMaximum) {\n            break;\n        }\n    }\n    return localMaximum;\n}\nfunction buildPartWithScoreQueue(scoreThreshold, localMaximumRadius, scores) {\n    var _a = scores.shape, height = _a[0], width = _a[1], numKeypoints = _a[2];\n    var queue = new maxHeap_1.MaxHeap(height * width * numKeypoints, function (_a) {\n        var score = _a.score;\n        return score;\n    });\n    for (var heatmapY = 0; heatmapY < height; ++heatmapY) {\n        for (var heatmapX = 0; heatmapX < width; ++heatmapX) {\n            for (var keypointId = 0; keypointId < numKeypoints; ++keypointId) {\n                var score = scores.get(heatmapY, heatmapX, keypointId);\n                if (score < scoreThreshold) {\n                    continue;\n                }\n                if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores)) {\n                    queue.enqueue({ score: score, part: { heatmapY: heatmapY, heatmapX: heatmapX, id: keypointId } });\n                }\n            }\n        }\n    }\n    return queue;\n}\nexports.buildPartWithScoreQueue = buildPartWithScoreQueue;\n//# sourceMappingURL=buildPartWithScoreQueue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction half(k) {\n    return Math.floor(k / 2);\n}\nvar MaxHeap = (function () {\n    function MaxHeap(maxSize, getElementValue) {\n        this.priorityQueue = new Array(maxSize);\n        this.numberOfElements = -1;\n        this.getElementValue = getElementValue;\n    }\n    MaxHeap.prototype.enqueue = function (x) {\n        this.priorityQueue[++this.numberOfElements] = x;\n        this.swim(this.numberOfElements);\n    };\n    MaxHeap.prototype.dequeue = function () {\n        var max = this.priorityQueue[0];\n        this.exchange(0, this.numberOfElements--);\n        this.sink(0);\n        this.priorityQueue[this.numberOfElements + 1] = null;\n        return max;\n    };\n    MaxHeap.prototype.empty = function () {\n        return this.numberOfElements === -1;\n    };\n    MaxHeap.prototype.size = function () {\n        return this.numberOfElements + 1;\n    };\n    MaxHeap.prototype.all = function () {\n        return this.priorityQueue.slice(0, this.numberOfElements + 1);\n    };\n    MaxHeap.prototype.max = function () {\n        return this.priorityQueue[0];\n    };\n    MaxHeap.prototype.swim = function (k) {\n        while (k > 0 && this.less(half(k), k)) {\n            this.exchange(k, half(k));\n            k = half(k);\n        }\n    };\n    MaxHeap.prototype.sink = function (k) {\n        while (2 * k <= this.numberOfElements) {\n            var j = 2 * k;\n            if (j < this.numberOfElements && this.less(j, j + 1)) {\n                j++;\n            }\n            if (!this.less(k, j)) {\n                break;\n            }\n            this.exchange(k, j);\n            k = j;\n        }\n    };\n    MaxHeap.prototype.getValueAt = function (i) {\n        return this.getElementValue(this.priorityQueue[i]);\n    };\n    MaxHeap.prototype.less = function (i, j) {\n        return this.getValueAt(i) < this.getValueAt(j);\n    };\n    MaxHeap.prototype.exchange = function (i, j) {\n        var t = this.priorityQueue[i];\n        this.priorityQueue[i] = this.priorityQueue[j];\n        this.priorityQueue[j] = t;\n    };\n    return MaxHeap;\n}());\nexports.MaxHeap = MaxHeap;\n//# sourceMappingURL=maxHeap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"./util\");\nvar parentChildrenTuples = keypoints_1.poseChain.map(function (_a) {\n    var parentJoinName = _a[0], childJoinName = _a[1];\n    return ([keypoints_1.partIds[parentJoinName], keypoints_1.partIds[childJoinName]]);\n});\nvar parentToChildEdges = parentChildrenTuples.map(function (_a) {\n    var childJointId = _a[1];\n    return childJointId;\n});\nvar childToParentEdges = parentChildrenTuples.map(function (_a) {\n    var parentJointId = _a[0];\n    return parentJointId;\n});\nfunction getDisplacement(edgeId, point, displacements) {\n    var numEdges = displacements.shape[2] / 2;\n    return {\n        y: displacements.get(point.y, point.x, edgeId),\n        x: displacements.get(point.y, point.x, numEdges + edgeId)\n    };\n}\nfunction getStridedIndexNearPoint(point, outputStride, height, width) {\n    return {\n        y: util_1.clamp(Math.round(point.y / outputStride), 0, height - 1),\n        x: util_1.clamp(Math.round(point.x / outputStride), 0, width - 1)\n    };\n}\nfunction traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements) {\n    var _a = scoresBuffer.shape, height = _a[0], width = _a[1];\n    var sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, outputStride, height, width);\n    var displacement = getDisplacement(edgeId, sourceKeypointIndices, displacements);\n    var displacedPoint = util_2.addVectors(sourceKeypoint.position, displacement);\n    var displacedPointIndices = getStridedIndexNearPoint(displacedPoint, outputStride, height, width);\n    var offsetPoint = util_1.getOffsetPoint(displacedPointIndices.y, displacedPointIndices.x, targetKeypointId, offsets);\n    var score = scoresBuffer.get(displacedPointIndices.y, displacedPointIndices.x, targetKeypointId);\n    var targetKeypoint = util_2.addVectors({\n        x: displacedPointIndices.x * outputStride,\n        y: displacedPointIndices.y * outputStride\n    }, { x: offsetPoint.x, y: offsetPoint.y });\n    return { position: targetKeypoint, part: keypoints_1.partNames[targetKeypointId], score: score };\n}\nfunction decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {\n    var numParts = scores.shape[2];\n    var numEdges = parentToChildEdges.length;\n    var instanceKeypoints = new Array(numParts);\n    var rootPart = root.part, rootScore = root.score;\n    var rootPoint = util_2.getImageCoords(rootPart, outputStride, offsets);\n    instanceKeypoints[rootPart.id] = {\n        score: rootScore,\n        part: keypoints_1.partNames[rootPart.id],\n        position: rootPoint\n    };\n    for (var edge = numEdges - 1; edge >= 0; --edge) {\n        var sourceKeypointId = parentToChildEdges[edge];\n        var targetKeypointId = childToParentEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);\n        }\n    }\n    for (var edge = 0; edge < numEdges; ++edge) {\n        var sourceKeypointId = childToParentEdges[edge];\n        var targetKeypointId = parentToChildEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);\n        }\n    }\n    return instanceKeypoints;\n}\nexports.decodePose = decodePose;\n//# sourceMappingURL=decodePose.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nfunction getOffsetPoint(y, x, keypoint, offsets) {\n    return {\n        y: offsets.get(y, x, keypoint),\n        x: offsets.get(y, x, keypoint + keypoints_1.NUM_KEYPOINTS)\n    };\n}\nexports.getOffsetPoint = getOffsetPoint;\nfunction getImageCoords(part, outputStride, offsets) {\n    var heatmapY = part.heatmapY, heatmapX = part.heatmapX, keypoint = part.id;\n    var _a = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets), y = _a.y, x = _a.x;\n    return {\n        x: part.heatmapX * outputStride + x,\n        y: part.heatmapY * outputStride + y\n    };\n}\nexports.getImageCoords = getImageCoords;\nfunction fillArray(element, size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = element;\n    }\n    return result;\n}\nexports.fillArray = fillArray;\nfunction clamp(a, min, max) {\n    if (a < min) {\n        return min;\n    }\n    if (a > max) {\n        return max;\n    }\n    return a;\n}\nexports.clamp = clamp;\nfunction squaredDistance(y1, x1, y2, x2) {\n    var dy = y2 - y1;\n    var dx = x2 - x1;\n    return dy * dy + dx * dx;\n}\nexports.squaredDistance = squaredDistance;\nfunction addVectors(a, b) {\n    return { x: a.x + b.x, y: a.y + b.y };\n}\nexports.addVectors = addVectors;\nfunction clampVector(a, min, max) {\n    return { y: clamp(a.y, min, max), x: clamp(a.x, min, max) };\n}\nexports.clampVector = clampVector;\n//# sourceMappingURL=util.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar checkpoint_loader_1 = require(\"./checkpoint_loader\");\nvar checkpoints_1 = require(\"./checkpoints\");\nvar mobilenet_1 = require(\"./mobilenet\");\nvar decodeMultiplePoses_1 = require(\"./multiPose/decodeMultiplePoses\");\nvar decodeSinglePose_1 = require(\"./singlePose/decodeSinglePose\");\nvar util_1 = require(\"./util\");\nfunction toInputTensor(input, resizeHeight, resizeWidth, flipHorizontal) {\n    var imageTensor = input instanceof tf.Tensor ? input : tf.fromPixels(input);\n    if (flipHorizontal) {\n        return imageTensor.reverse(1).resizeBilinear([resizeHeight, resizeWidth]);\n    }\n    else {\n        return imageTensor.resizeBilinear([resizeHeight, resizeWidth]);\n    }\n}\nvar PoseNet = (function () {\n    function PoseNet(mobileNet) {\n        this.mobileNet = mobileNet;\n    }\n    PoseNet.prototype.predictForSinglePose = function (input, outputStride) {\n        var _this = this;\n        if (outputStride === void 0) { outputStride = 16; }\n        mobilenet_1.assertValidOutputStride(outputStride);\n        return tf.tidy(function () {\n            var mobileNetOutput = _this.mobileNet.predict(input, outputStride);\n            var heatmaps = _this.mobileNet.convToOutput(mobileNetOutput, 'heatmap_2');\n            var offsets = _this.mobileNet.convToOutput(mobileNetOutput, 'offset_2');\n            return { heatmapScores: heatmaps.sigmoid(), offsets: offsets };\n        });\n    };\n    PoseNet.prototype.predictForMultiPose = function (input, outputStride) {\n        var _this = this;\n        if (outputStride === void 0) { outputStride = 16; }\n        return tf.tidy(function () {\n            var mobileNetOutput = _this.mobileNet.predict(input, outputStride);\n            var heatmaps = _this.mobileNet.convToOutput(mobileNetOutput, 'heatmap_2');\n            var offsets = _this.mobileNet.convToOutput(mobileNetOutput, 'offset_2');\n            var displacementFwd = _this.mobileNet.convToOutput(mobileNetOutput, 'displacement_fwd_2');\n            var displacementBwd = _this.mobileNet.convToOutput(mobileNetOutput, 'displacement_bwd_2');\n            return {\n                heatmapScores: heatmaps.sigmoid(),\n                offsets: offsets,\n                displacementFwd: displacementFwd,\n                displacementBwd: displacementBwd\n            };\n        });\n    };\n    PoseNet.prototype.estimateSinglePose = function (input, imageScaleFactor, flipHorizontal, outputStride) {\n        if (imageScaleFactor === void 0) { imageScaleFactor = 0.5; }\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\n        if (outputStride === void 0) { outputStride = 16; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, height, width, resizedHeight, resizedWidth, _b, heatmapScores, offsets, pose, scaleY, scaleX;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        mobilenet_1.assertValidOutputStride(outputStride);\n                        mobilenet_1.assertValidScaleFactor(imageScaleFactor);\n                        _a = input instanceof tf.Tensor ?\n                            [input.shape[0], input.shape[1]] :\n                            [input.height, input.width], height = _a[0], width = _a[1];\n                        resizedHeight = util_1.getValidResolution(imageScaleFactor, height, outputStride);\n                        resizedWidth = util_1.getValidResolution(imageScaleFactor, width, outputStride);\n                        _b = tf.tidy(function () {\n                            var inputTensor = toInputTensor(input, resizedHeight, resizedWidth, flipHorizontal);\n                            return _this.predictForSinglePose(inputTensor, outputStride);\n                        }), heatmapScores = _b.heatmapScores, offsets = _b.offsets;\n                        return [4, decodeSinglePose_1.decodeSinglePose(heatmapScores, offsets, outputStride)];\n                    case 1:\n                        pose = _c.sent();\n                        heatmapScores.dispose();\n                        offsets.dispose();\n                        scaleY = height / resizedHeight;\n                        scaleX = width / resizedWidth;\n                        return [2, util_1.scalePose(pose, scaleY, scaleX)];\n                }\n            });\n        });\n    };\n    PoseNet.prototype.estimateMultiplePoses = function (input, imageScaleFactor, flipHorizontal, outputStride, maxDetections, scoreThreshold, nmsRadius) {\n        if (imageScaleFactor === void 0) { imageScaleFactor = 0.5; }\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\n        if (outputStride === void 0) { outputStride = 16; }\n        if (maxDetections === void 0) { maxDetections = 5; }\n        if (scoreThreshold === void 0) { scoreThreshold = .5; }\n        if (nmsRadius === void 0) { nmsRadius = 20; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, height, width, resizedHeight, resizedWidth, _b, heatmapScores, offsets, displacementFwd, displacementBwd, poses, scaleY, scaleX;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        mobilenet_1.assertValidOutputStride(outputStride);\n                        mobilenet_1.assertValidScaleFactor(imageScaleFactor);\n                        _a = input instanceof tf.Tensor ?\n                            [input.shape[0], input.shape[1]] :\n                            [input.height, input.width], height = _a[0], width = _a[1];\n                        resizedHeight = util_1.getValidResolution(imageScaleFactor, height, outputStride);\n                        resizedWidth = util_1.getValidResolution(imageScaleFactor, width, outputStride);\n                        _b = tf.tidy(function () {\n                            var inputTensor = toInputTensor(input, resizedHeight, resizedWidth, flipHorizontal);\n                            return _this.predictForMultiPose(inputTensor, outputStride);\n                        }), heatmapScores = _b.heatmapScores, offsets = _b.offsets, displacementFwd = _b.displacementFwd, displacementBwd = _b.displacementBwd;\n                        return [4, decodeMultiplePoses_1.decodeMultiplePoses(heatmapScores, offsets, displacementFwd, displacementBwd, outputStride, maxDetections, scoreThreshold, nmsRadius)];\n                    case 1:\n                        poses = _c.sent();\n                        heatmapScores.dispose();\n                        offsets.dispose();\n                        displacementFwd.dispose();\n                        displacementBwd.dispose();\n                        scaleY = height / resizedHeight;\n                        scaleX = width / resizedWidth;\n                        return [2, util_1.scalePoses(poses, scaleY, scaleX)];\n                }\n            });\n        });\n    };\n    PoseNet.prototype.dispose = function () {\n        this.mobileNet.dispose();\n    };\n    return PoseNet;\n}());\nexports.PoseNet = PoseNet;\nfunction load(multiplier) {\n    if (multiplier === void 0) { multiplier = 1.01; }\n    return __awaiter(this, void 0, void 0, function () {\n        var possibleMultipliers, mobileNet;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tf == null) {\n                        throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" +\n                            \"also include @tensorflow/tfjs on the page before using this model.\");\n                    }\n                    possibleMultipliers = Object.keys(checkpoints_1.checkpoints);\n                    tf.util.assert(typeof multiplier === 'number', \"got multiplier type of \" + typeof multiplier + \" when it should be a \" +\n                        \"number.\");\n                    tf.util.assert(possibleMultipliers.indexOf(multiplier.toString()) >= 0, \"invalid multiplier value of \" + multiplier + \".  No checkpoint exists for that \" +\n                        (\"multiplier. Must be one of \" + possibleMultipliers.join(',') + \".\"));\n                    return [4, exports.mobilenetLoader.load(multiplier)];\n                case 1:\n                    mobileNet = _a.sent();\n                    return [2, new PoseNet(mobileNet)];\n            }\n        });\n    });\n}\nexports.load = load;\nexports.mobilenetLoader = {\n    load: function (multiplier) { return __awaiter(_this, void 0, void 0, function () {\n        var checkpoint, checkpointLoader, variables;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    checkpoint = checkpoints_1.checkpoints[multiplier];\n                    checkpointLoader = new checkpoint_loader_1.CheckpointLoader(checkpoint.url);\n                    return [4, checkpointLoader.getAllVariables()];\n                case 1:\n                    variables = _a.sent();\n                    return [2, new mobilenet_1.MobileNet(variables, checkpoint.architecture)];\n            }\n        });\n    }); }\n};\n//# sourceMappingURL=posenet_model.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mobilenet_1 = require(\"./mobilenet\");\nvar GOOGLE_CLOUD_STORAGE_DIR = 'https://storage.googleapis.com/tfjs-models/weights/posenet/';\nexports.checkpoints = {\n    1.01: {\n        url: GOOGLE_CLOUD_STORAGE_DIR + 'mobilenet_v1_101/',\n        architecture: mobilenet_1.mobileNetArchitectures[100]\n    },\n    1.0: {\n        url: GOOGLE_CLOUD_STORAGE_DIR + 'mobilenet_v1_100/',\n        architecture: mobilenet_1.mobileNetArchitectures[100]\n    },\n    0.75: {\n        url: GOOGLE_CLOUD_STORAGE_DIR + 'mobilenet_v1_075/',\n        architecture: mobilenet_1.mobileNetArchitectures[75]\n    },\n    0.5: {\n        url: GOOGLE_CLOUD_STORAGE_DIR + 'mobilenet_v1_050/',\n        architecture: mobilenet_1.mobileNetArchitectures[50]\n    }\n};\n//# sourceMappingURL=checkpoints.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nvar util_1 = require(\"../util\");\nvar argmax2d_1 = require(\"./argmax2d\");\nvar util_2 = require(\"./util\");\nfunction decodeSinglePose(heatmapScores, offsets, outputStride) {\n    return __awaiter(this, void 0, void 0, function () {\n        var totalScore, heatmapValues, _a, scoresBuffer, offsetsBuffer, heatmapValuesBuffer, offsetPoints, offsetPointsBuffer, keypointConfidence, keypoints;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    totalScore = 0.0;\n                    heatmapValues = argmax2d_1.argmax2d(heatmapScores);\n                    return [4, Promise.all([\n                            util_1.toTensorBuffer(heatmapScores), util_1.toTensorBuffer(offsets),\n                            util_1.toTensorBuffer(heatmapValues, 'int32')\n                        ])];\n                case 1:\n                    _a = _b.sent(), scoresBuffer = _a[0], offsetsBuffer = _a[1], heatmapValuesBuffer = _a[2];\n                    offsetPoints = util_2.getOffsetPoints(heatmapValuesBuffer, outputStride, offsetsBuffer);\n                    return [4, util_1.toTensorBuffer(offsetPoints)];\n                case 2:\n                    offsetPointsBuffer = _b.sent();\n                    keypointConfidence = Array.from(util_2.getPointsConfidence(scoresBuffer, heatmapValuesBuffer));\n                    keypoints = keypointConfidence.map(function (score, keypointId) {\n                        totalScore += score;\n                        return {\n                            position: {\n                                y: offsetPointsBuffer.get(keypointId, 0),\n                                x: offsetPointsBuffer.get(keypointId, 1)\n                            },\n                            part: keypoints_1.partNames[keypointId],\n                            score: score\n                        };\n                    });\n                    heatmapValues.dispose();\n                    offsetPoints.dispose();\n                    return [2, { keypoints: keypoints, score: totalScore / keypoints.length }];\n            }\n        });\n    });\n}\nexports.decodeSinglePose = decodeSinglePose;\n//# sourceMappingURL=decodeSinglePose.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nfunction mod(a, b) {\n    return tf.tidy(function () {\n        var floored = a.div(tf.scalar(b, 'int32'));\n        return a.sub(floored.mul(tf.scalar(b, 'int32')));\n    });\n}\nfunction argmax2d(inputs) {\n    var _a = inputs.shape, height = _a[0], width = _a[1], depth = _a[2];\n    return tf.tidy(function () {\n        var reshaped = inputs.reshape([height * width, depth]);\n        var coords = reshaped.argMax(0);\n        var yCoords = coords.div(tf.scalar(width, 'int32')).expandDims(1);\n        var xCoords = mod(coords, width).expandDims(1);\n        return tf.concat([yCoords, xCoords], 1);\n    });\n}\nexports.argmax2d = argmax2d;\n//# sourceMappingURL=argmax2d.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar keypoints_1 = require(\"../keypoints\");\nfunction getPointsConfidence(heatmapScores, heatMapCoords) {\n    var numKeypoints = heatMapCoords.shape[0];\n    var result = new Float32Array(numKeypoints);\n    for (var keypoint = 0; keypoint < numKeypoints; keypoint++) {\n        var y = heatMapCoords.get(keypoint, 0);\n        var x = heatMapCoords.get(keypoint, 1);\n        result[keypoint] = heatmapScores.get(y, x, keypoint);\n    }\n    return result;\n}\nexports.getPointsConfidence = getPointsConfidence;\nfunction getOffsetPoint(y, x, keypoint, offsetsBuffer) {\n    return {\n        y: offsetsBuffer.get(y, x, keypoint),\n        x: offsetsBuffer.get(y, x, keypoint + keypoints_1.NUM_KEYPOINTS)\n    };\n}\nfunction getOffsetVectors(heatMapCoordsBuffer, offsetsBuffer) {\n    var result = [];\n    for (var keypoint = 0; keypoint < keypoints_1.NUM_KEYPOINTS; keypoint++) {\n        var heatmapY = heatMapCoordsBuffer.get(keypoint, 0).valueOf();\n        var heatmapX = heatMapCoordsBuffer.get(keypoint, 1).valueOf();\n        var _a = getOffsetPoint(heatmapY, heatmapX, keypoint, offsetsBuffer), x = _a.x, y = _a.y;\n        result.push(y);\n        result.push(x);\n    }\n    return tf.tensor2d(result, [keypoints_1.NUM_KEYPOINTS, 2]);\n}\nexports.getOffsetVectors = getOffsetVectors;\nfunction getOffsetPoints(heatMapCoordsBuffer, outputStride, offsetsBuffer) {\n    return tf.tidy(function () {\n        var offsetVectors = getOffsetVectors(heatMapCoordsBuffer, offsetsBuffer);\n        return heatMapCoordsBuffer.toTensor()\n            .mul(tf.scalar(outputStride, 'int32'))\n            .toFloat()\n            .add(offsetVectors);\n    });\n}\nexports.getOffsetPoints = getOffsetPoints;\n//# sourceMappingURL=util.js.map"]}